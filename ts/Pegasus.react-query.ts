/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery } from "@tanstack/react-query";
import { ExecuteMsg, Timestamp, Uint64, TokenMsg, InstantiateMsg, ExpiryRange, Addr, OfferResponse, Offer, Token, OffersResponse, ParamsResponse, SudoParams, QueryMsg } from "./Pegasus.types";
import { PegasusQueryClient } from "./Pegasus.client";
export const pegasusQueryKeys = {
  contract: ([{
    contract: "pegasus"
  }] as const),
  address: (contractAddress: string) => ([{
    ...pegasusQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  offer: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...pegasusQueryKeys.address(contractAddress)[0],
    method: "offer",
    args
  }] as const),
  offersBySender: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...pegasusQueryKeys.address(contractAddress)[0],
    method: "offers_by_sender",
    args
  }] as const),
  offersByPeer: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...pegasusQueryKeys.address(contractAddress)[0],
    method: "offers_by_peer",
    args
  }] as const),
  params: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...pegasusQueryKeys.address(contractAddress)[0],
    method: "params",
    args
  }] as const)
};
export interface PegasusReactQuery<TResponse, TData = TResponse> {
  client: PegasusQueryClient;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface PegasusParamsQuery<TData> extends PegasusReactQuery<ParamsResponse, TData> {}
export function usePegasusParamsQuery<TData = ParamsResponse>({
  client,
  options
}: PegasusParamsQuery<TData>) {
  return useQuery<ParamsResponse, Error, TData>(pegasusQueryKeys.params(client.contractAddress), () => client.params(), options);
}
export interface PegasusOffersByPeerQuery<TData> extends PegasusReactQuery<OffersByPeerResponse, TData> {
  args: {
    peer: string;
  };
}
export function usePegasusOffersByPeerQuery<TData = OffersByPeerResponse>({
  client,
  args,
  options
}: PegasusOffersByPeerQuery<TData>) {
  return useQuery<OffersByPeerResponse, Error, TData>(pegasusQueryKeys.offersByPeer(client.contractAddress, args), () => client.offersByPeer({
    peer: args.peer
  }), options);
}
export interface PegasusOffersBySenderQuery<TData> extends PegasusReactQuery<OffersBySenderResponse, TData> {
  args: {
    sender: string;
  };
}
export function usePegasusOffersBySenderQuery<TData = OffersBySenderResponse>({
  client,
  args,
  options
}: PegasusOffersBySenderQuery<TData>) {
  return useQuery<OffersBySenderResponse, Error, TData>(pegasusQueryKeys.offersBySender(client.contractAddress, args), () => client.offersBySender({
    sender: args.sender
  }), options);
}
export interface PegasusOfferQuery<TData> extends PegasusReactQuery<OfferResponse, TData> {
  args: {
    id: number;
  };
}
export function usePegasusOfferQuery<TData = OfferResponse>({
  client,
  args,
  options
}: PegasusOfferQuery<TData>) {
  return useQuery<OfferResponse, Error, TData>(pegasusQueryKeys.offer(client.contractAddress, args), () => client.offer({
    id: args.id
  }), options);
}